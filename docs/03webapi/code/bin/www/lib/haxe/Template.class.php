<?php

// Generated by Haxe 3.4.4
class haxe_Template {
	public function __construct($str) {
		if(!php_Boot::$skip_constructor) {
		$tokens = $this->parseTokens($str);
		$this->expr = $this->parseBlock($tokens);
		if(!$tokens->isEmpty()) {
			throw new HException("Unexpected '" . Std::string($tokens->first()->s) . "'");
		}
	}}
	public $expr;
	public $context;
	public $macros;
	public $stack;
	public $buf;
	public function execute($context, $macros = null) {
		$tmp = null;
		if($macros === null) {
			$tmp = _hx_anonymous(array());
		} else {
			$tmp = $macros;
		}
		$this->macros = $tmp;
		$this->context = $context;
		$this->stack = new HList();
		$this->buf = new StringBuf();
		$this->run($this->expr);
		return $this->buf->b;
	}
	public function resolve($v) {
		if($v === "__current__") {
			return $this->context;
		}
		$value = Reflect::getProperty($this->context, $v);
		$tmp = null;
		if($value === null) {
			$o = $this->context;
			$tmp = _hx_has_field($o, $v);
		} else {
			$tmp = true;
		}
		if($tmp) {
			return $value;
		}
		{
			$ctx = $this->stack->iterator();
			while($ctx->hasNext()) {
				$ctx1 = $ctx->next();
				$value = Reflect::getProperty($ctx1, $v);
				$tmp1 = null;
				if($value === null) {
					$tmp1 = _hx_has_field($ctx1, $v);
				} else {
					$tmp1 = true;
				}
				if($tmp1) {
					return $value;
				}
				unset($tmp1,$ctx1);
			}
		}
		return Reflect::field(haxe_Template::$globals, $v);
	}
	public function parseTokens($data) {
		$tokens = new HList();
		while(haxe_Template::$splitter->match($data)) {
			$p = haxe_Template::$splitter->matchedPos();
			if($p->pos > 0) {
				$tokens->add(_hx_anonymous(array("p" => _hx_substr($data, 0, $p->pos), "s" => true, "l" => null)));
			}
			if(_hx_char_code_at($data, $p->pos) === 58) {
				$tokens->add(_hx_anonymous(array("p" => _hx_substr($data, $p->pos + 2, $p->len - 4), "s" => false, "l" => null)));
				$data = haxe_Template::$splitter->matchedRight();
				continue;
			}
			$parp = $p->pos + $p->len;
			$npar = 1;
			$params = (new _hx_array(array()));
			$part = "";
			while(true) {
				$c = _hx_char_code_at($data, $parp);
				$parp = $parp + 1;
				if($c === 40) {
					$npar = $npar + 1;
				} else {
					if($c === 41) {
						$npar = $npar - 1;
						if($npar <= 0) {
							break;
						}
					} else {
						if($c === null) {
							throw new HException("Unclosed macro parenthesis");
						}
					}
				}
				$tmp = null;
				if($c === 44) {
					$tmp = $npar === 1;
				} else {
					$tmp = false;
				}
				if($tmp) {
					$params->push($part);
					$part = "";
				} else {
					$part = _hx_string_or_null($part) . _hx_string_or_null(chr($c));
				}
				unset($tmp,$c);
			}
			$params->push($part);
			$tokens->add(_hx_anonymous(array("p" => haxe_Template::$splitter->matched(2), "s" => false, "l" => $params)));
			$data = _hx_substr($data, $parp, strlen($data) - $parp);
			unset($part,$parp,$params,$p,$npar);
		}
		if(strlen($data) > 0) {
			$tokens->add(_hx_anonymous(array("p" => $data, "s" => true, "l" => null)));
		}
		return $tokens;
	}
	public function parseBlock($tokens) {
		$l = new HList();
		while(true) {
			$t = $tokens->first();
			if($t === null) {
				break;
			}
			$tmp = null;
			if(!$t->s) {
				$tmp1 = null;
				if($t->p !== "end") {
					$tmp1 = $t->p === "else";
				} else {
					$tmp1 = true;
				}
				if(!$tmp1) {
					$tmp = _hx_substr($t->p, 0, 7) === "elseif ";
				} else {
					$tmp = true;
				}
				unset($tmp1);
			} else {
				$tmp = false;
			}
			if($tmp) {
				break;
			}
			$l->add($this->parse($tokens));
			unset($tmp,$t);
		}
		if($l->length === 1) {
			return $l->first();
		}
		return haxe__Template_TemplateExpr::OpBlock($l);
	}
	public function parse($tokens) {
		$t = $tokens->pop();
		$p = $t->p;
		if($t->s) {
			return haxe__Template_TemplateExpr::OpStr($p);
		}
		if($t->l !== null) {
			$pe = new HList();
			{
				$_g = 0;
				$_g1 = $t->l;
				while($_g < $_g1->length) {
					$p1 = $_g1[$_g];
					$_g = $_g + 1;
					$pe->add($this->parseBlock($this->parseTokens($p1)));
					unset($p1);
				}
			}
			return haxe__Template_TemplateExpr::OpMacro($p, $pe);
		}
		if(_hx_substr($p, 0, 3) === "if ") {
			$p = _hx_substr($p, 3, strlen($p) - 3);
			$e = $this->parseExpr($p);
			$eif = $this->parseBlock($tokens);
			$t1 = $tokens->first();
			$eelse = null;
			if($t1 === null) {
				throw new HException("Unclosed 'if'");
			}
			if($t1->p === "end") {
				$tokens->pop();
				$eelse = null;
			} else {
				if($t1->p === "else") {
					$tokens->pop();
					$eelse = $this->parseBlock($tokens);
					$t1 = $tokens->pop();
					$tmp = null;
					if($t1 !== null) {
						$tmp = $t1->p !== "end";
					} else {
						$tmp = true;
					}
					if($tmp) {
						throw new HException("Unclosed 'else'");
					}
				} else {
					$t1->p = _hx_substr($t1->p, 4, strlen($t1->p) - 4);
					$eelse = $this->parse($tokens);
				}
			}
			return haxe__Template_TemplateExpr::OpIf($e, $eif, $eelse);
		}
		if(_hx_substr($p, 0, 8) === "foreach ") {
			$p = _hx_substr($p, 8, strlen($p) - 8);
			$e1 = $this->parseExpr($p);
			$efor = $this->parseBlock($tokens);
			$t2 = $tokens->pop();
			$tmp1 = null;
			if($t2 !== null) {
				$tmp1 = $t2->p !== "end";
			} else {
				$tmp1 = true;
			}
			if($tmp1) {
				throw new HException("Unclosed 'foreach'");
			}
			return haxe__Template_TemplateExpr::OpForeach($e1, $efor);
		}
		if(haxe_Template::$expr_splitter->match($p)) {
			return haxe__Template_TemplateExpr::OpExpr($this->parseExpr($p));
		}
		return haxe__Template_TemplateExpr::OpVar($p);
	}
	public function parseExpr($data) {
		$l = new HList();
		$expr = $data;
		while(haxe_Template::$expr_splitter->match($data)) {
			$p = haxe_Template::$expr_splitter->matchedPos();
			$k = $p->pos + $p->len;
			if($p->pos !== 0) {
				$l->add(_hx_anonymous(array("p" => _hx_substr($data, 0, $p->pos), "s" => true)));
			}
			$p1 = haxe_Template::$expr_splitter->matched(0);
			$l->add(_hx_anonymous(array("p" => $p1, "s" => _hx_index_of($p1, "\"", null) >= 0)));
			$data = haxe_Template::$expr_splitter->matchedRight();
			unset($p1,$p,$k);
		}
		if(strlen($data) !== 0) {
			$l->add(_hx_anonymous(array("p" => $data, "s" => true)));
		}
		$e = null;
		try {
			$e = $this->makeExpr($l);
			if(!$l->isEmpty()) {
				throw new HException($l->first()->p);
			}
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			if(is_string($s = $_ex_)){
				throw new HException("Unexpected '" . _hx_string_or_null($s) . "' in " . _hx_string_or_null($expr));
			} else throw $__hx__e;;
		}
		return array(new _hx_lambda(array(&$e, &$expr), "haxe_Template_0"), 'execute');
	}
	public function makeConst($v) {
		haxe_Template::$expr_trim->match($v);
		$v = haxe_Template::$expr_trim->matched(1);
		if(_hx_char_code_at($v, 0) === 34) {
			$str = _hx_substr($v, 1, strlen($v) - 2);
			return array(new _hx_lambda(array(&$str), "haxe_Template_1"), 'execute');
		}
		if(haxe_Template::$expr_int->match($v)) {
			$i = Std::parseInt($v);
			return array(new _hx_lambda(array(&$i), "haxe_Template_2"), 'execute');
		}
		if(haxe_Template::$expr_float->match($v)) {
			$f = Std::parseFloat($v);
			return array(new _hx_lambda(array(&$f), "haxe_Template_3"), 'execute');
		}
		$me = $this;
		return array(new _hx_lambda(array(&$me, &$v), "haxe_Template_4"), 'execute');
	}
	public function makePath($e, $l) {
		$p = $l->first();
		$tmp = null;
		if($p !== null) {
			$tmp = $p->p !== ".";
		} else {
			$tmp = true;
		}
		if($tmp) {
			return $e;
		}
		$l->pop();
		$field = $l->pop();
		$tmp1 = null;
		if($field !== null) {
			$tmp1 = !$field->s;
		} else {
			$tmp1 = true;
		}
		if($tmp1) {
			throw new HException($field->p);
		}
		$f = $field->p;
		haxe_Template::$expr_trim->match($f);
		$f = haxe_Template::$expr_trim->matched(1);
		return $this->makePath(array(new _hx_lambda(array(&$e, &$f), "haxe_Template_5"), 'execute'), $l);
	}
	public function makeExpr($l) {
		return $this->makePath($this->makeExpr2($l), $l);
	}
	public function makeExpr2($l) {
		$p = $l->pop();
		if($p === null) {
			throw new HException("<eof>");
		}
		if($p->s) {
			return $this->makeConst($p->p);
		}
		{
			$_g = $p->p;
			switch($_g) {
			case "!":{
				$e = $this->makeExpr($l);
				return array(new _hx_lambda(array(&$e), "haxe_Template_6"), 'execute');
			}break;
			case "(":{
				$e1 = $this->makeExpr($l);
				$p1 = $l->pop();
				$tmp = null;
				if($p1 !== null) {
					$tmp = $p1->s;
				} else {
					$tmp = true;
				}
				if($tmp) {
					throw new HException($p1);
				}
				if($p1->p === ")") {
					return $e1;
				}
				$e2 = $this->makeExpr($l);
				$p2 = $l->pop();
				$tmp1 = null;
				if($p2 !== null) {
					$tmp1 = $p2->p !== ")";
				} else {
					$tmp1 = true;
				}
				if($tmp1) {
					throw new HException($p2);
				}
				$_g1 = $p1->p;
				switch($_g1) {
				case "!=":{
					return array(new _hx_lambda(array(&$e1, &$e2), "haxe_Template_7"), 'execute');
				}break;
				case "&&":{
					return array(new _hx_lambda(array(&$e1, &$e2), "haxe_Template_8"), 'execute');
				}break;
				case "*":{
					return array(new _hx_lambda(array(&$e1, &$e2), "haxe_Template_9"), 'execute');
				}break;
				case "+":{
					return array(new _hx_lambda(array(&$e1, &$e2), "haxe_Template_10"), 'execute');
				}break;
				case "-":{
					return array(new _hx_lambda(array(&$e1, &$e2), "haxe_Template_11"), 'execute');
				}break;
				case "/":{
					return array(new _hx_lambda(array(&$e1, &$e2), "haxe_Template_12"), 'execute');
				}break;
				case "<":{
					return array(new _hx_lambda(array(&$e1, &$e2), "haxe_Template_13"), 'execute');
				}break;
				case "<=":{
					return array(new _hx_lambda(array(&$e1, &$e2), "haxe_Template_14"), 'execute');
				}break;
				case "==":{
					return array(new _hx_lambda(array(&$e1, &$e2), "haxe_Template_15"), 'execute');
				}break;
				case ">":{
					return array(new _hx_lambda(array(&$e1, &$e2), "haxe_Template_16"), 'execute');
				}break;
				case ">=":{
					return array(new _hx_lambda(array(&$e1, &$e2), "haxe_Template_17"), 'execute');
				}break;
				case "||":{
					return array(new _hx_lambda(array(&$e1, &$e2), "haxe_Template_18"), 'execute');
				}break;
				default:{
					throw new HException("Unknown operation " . _hx_string_or_null($p1->p));
				}break;
				}
			}break;
			case "-":{
				$e3 = $this->makeExpr($l);
				return array(new _hx_lambda(array(&$e3), "haxe_Template_19"), 'execute');
			}break;
			}
		}
		throw new HException($p->p);
	}
	public function run($e) {
		switch($e->index) {
		case 0:{
			$v = _hx_deref($e)->params[0];
			$tmp = $this->buf;
			$tmp->add(Std::string($this->resolve($v)));
		}break;
		case 1:{
			$e1 = _hx_deref($e)->params[0];
			$tmp1 = $this->buf;
			$tmp1->add(Std::string(call_user_func($e1)));
		}break;
		case 2:{
			$eelse = _hx_deref($e)->params[2];
			$eif = _hx_deref($e)->params[1];
			$e2 = _hx_deref($e)->params[0];
			{
				$v1 = call_user_func($e2);
				$tmp2 = null;
				if($v1 !== null) {
					$tmp2 = _hx_equal($v1, false);
				} else {
					$tmp2 = true;
				}
				if($tmp2) {
					if($eelse !== null) {
						$this->run($eelse);
					}
				} else {
					$this->run($eif);
				}
			}
		}break;
		case 3:{
			$str = _hx_deref($e)->params[0];
			$this->buf->add($str);
		}break;
		case 4:{
			$l = _hx_deref($e)->params[0];
			{
				$e3 = $l->iterator();
				while($e3->hasNext()) {
					$e4 = $e3->next();
					$this->run($e4);
					unset($e4);
				}
			}
		}break;
		case 5:{
			$loop = _hx_deref($e)->params[1];
			$e5 = _hx_deref($e)->params[0];
			{
				$v2 = call_user_func($e5);
				try {
					$x = $v2->iterator();
					if(_hx_field($x, "hasNext") === null) {
						throw new HException(null);
					}
					$v2 = $x;
				}catch(Exception $__hx__e) {
					$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
					$e6 = $_ex_;
					{
						try {
							if(_hx_field($v2, "hasNext") === null) {
								throw new HException(null);
							}
						}catch(Exception $__hx__e) {
							$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
							$e7 = $_ex_;
							{
								throw new HException("Cannot iter on " . Std::string($v2));
							}
						}
					}
				}
				$this->stack->push($this->context);
				$v3 = $v2;
				{
					$ctx = $v3;
					while($ctx->hasNext()) {
						$ctx1 = $ctx->next();
						$this->context = $ctx1;
						$this->run($loop);
						unset($ctx1);
					}
				}
				$this->context = $this->stack->pop();
			}
		}break;
		case 6:{
			$params = _hx_deref($e)->params[1];
			$m = _hx_deref($e)->params[0];
			{
				$v4 = Reflect::field($this->macros, $m);
				$pl = new _hx_array(array());
				$old = $this->buf;
				$pl->push((property_exists($this, "resolve") ? $this->resolve: array($this, "resolve")));
				{
					$p = $params->iterator();
					while($p->hasNext()) {
						$p1 = $p->next();
						if($p1->index === 0) {
							$v5 = _hx_deref($p1)->params[0];
							$pl->push($this->resolve($v5));
							unset($v5);
						} else {
							$this->buf = new StringBuf();
							$this->run($p1);
							$pl->push($this->buf->b);
						}
						unset($p1);
					}
				}
				$this->buf = $old;
				try {
					$tmp3 = $this->buf;
					$tmp3->add(Std::string(Reflect::callMethod($this->macros, $v4, $pl)));
				}catch(Exception $__hx__e) {
					$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
					$e8 = $_ex_;
					{
						$plstr = null;
						try {
							$plstr = $pl->join(",");
						}catch(Exception $__hx__e) {
							$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
							$e9 = $_ex_;
							{
								$plstr = "???";
							}
						}
						$msg = "Macro call " . _hx_string_or_null($m) . "(" . _hx_string_or_null($plstr) . ") failed (" . Std::string($e8) . ")";
						throw new HException($msg);
					}
				}
			}
		}break;
		}
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $splitter;
	static $expr_splitter;
	static $expr_trim;
	static $expr_int;
	static $expr_float;
	static function globals() { $args = func_get_args(); return call_user_func_array(self::$globals, $args); }
	static $globals;
	function __toString() { return 'haxe.Template'; }
}
haxe_Template::$splitter = new EReg("(::[A-Za-z0-9_ ()&|!+=/><*.\"-]+::|\\\$\\\$([A-Za-z0-9_-]+)\\()", "");
haxe_Template::$expr_splitter = new EReg("(\\(|\\)|[ \x0D\x0A\x09]*\"[^\"]*\"[ \x0D\x0A\x09]*|[!+=/><*.&|-]+)", "");
haxe_Template::$expr_trim = new EReg("^[ ]*([^ ]+)[ ]*\$", "");
haxe_Template::$expr_int = new EReg("^[0-9]+\$", "");
haxe_Template::$expr_float = new EReg("^([+-]?)(?=\\d|,\\d)\\d*(,\\d*)?([Ee]([+-]?\\d+))?\$", "");
haxe_Template::$globals = _hx_anonymous(array());
function haxe_Template_0(&$e, &$expr) {
	{
		try {
			return call_user_func($e);
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$exc = $_ex_;
			{
				$tmp = "Error : " . Std::string($exc) . " in ";
				throw new HException(_hx_string_or_null($tmp) . _hx_string_or_null($expr));
			}
		}
	}
}
function haxe_Template_1(&$str) {
	{
		return $str;
	}
}
function haxe_Template_2(&$i) {
	{
		return $i;
	}
}
function haxe_Template_3(&$f) {
	{
		return $f;
	}
}
function haxe_Template_4(&$me, &$v) {
	{
		return $me->resolve($v);
	}
}
function haxe_Template_5(&$e, &$f) {
	{
		$tmp2 = call_user_func($e);
		return Reflect::field($tmp2, $f);
	}
}
function haxe_Template_6(&$e) {
	{
		$v = call_user_func($e);
		if($v !== null) {
			return _hx_equal($v, false);
		} else {
			return true;
		}
	}
}
function haxe_Template_7(&$e1, &$e2) {
	{
		$tmp2 = call_user_func($e1);
		return !_hx_equal($tmp2, call_user_func($e2));
	}
}
function haxe_Template_8(&$e1, &$e2) {
	{
		$tmp3 = null;
		if(call_user_func($e1)) {
			$tmp3 = call_user_func($e2);
		} else {
			$tmp3 = false;
		}
		return $tmp3;
	}
}
function haxe_Template_9(&$e1, &$e2) {
	{
		$tmp4 = call_user_func($e1);
		return $tmp4 * call_user_func($e2);
	}
}
function haxe_Template_10(&$e1, &$e2) {
	{
		$tmp5 = call_user_func($e1);
		return _hx_add($tmp5, call_user_func($e2));
	}
}
function haxe_Template_11(&$e1, &$e2) {
	{
		$tmp6 = call_user_func($e1);
		return $tmp6 - call_user_func($e2);
	}
}
function haxe_Template_12(&$e1, &$e2) {
	{
		$tmp7 = call_user_func($e1);
		return $tmp7 / call_user_func($e2);
	}
}
function haxe_Template_13(&$e1, &$e2) {
	{
		$tmp8 = call_user_func($e1);
		return $tmp8 < call_user_func($e2);
	}
}
function haxe_Template_14(&$e1, &$e2) {
	{
		$tmp9 = call_user_func($e1);
		return $tmp9 <= call_user_func($e2);
	}
}
function haxe_Template_15(&$e1, &$e2) {
	{
		$tmp10 = call_user_func($e1);
		return _hx_equal($tmp10, call_user_func($e2));
	}
}
function haxe_Template_16(&$e1, &$e2) {
	{
		$tmp11 = call_user_func($e1);
		return $tmp11 > call_user_func($e2);
	}
}
function haxe_Template_17(&$e1, &$e2) {
	{
		$tmp12 = call_user_func($e1);
		return $tmp12 >= call_user_func($e2);
	}
}
function haxe_Template_18(&$e1, &$e2) {
	{
		$tmp13 = null;
		if(!call_user_func($e1)) {
			$tmp13 = call_user_func($e2);
		} else {
			$tmp13 = true;
		}
		return $tmp13;
	}
}
function haxe_Template_19(&$e3) {
	{
		return -call_user_func($e3);
	}
}
