<?php

// Generated by Haxe 3.4.4
class haxe_Unserializer {
	public function __construct($buf) {
		if(!php_Boot::$skip_constructor) {
		$this->buf = $buf;
		$this->length = strlen($buf);
		$this->pos = 0;
		$this->scache = new _hx_array(array());
		$this->cache = new _hx_array(array());
		$r = haxe_Unserializer::$DEFAULT_RESOLVER;
		if($r === null) {
			$r = new haxe__Unserializer_DefaultResolver();
			haxe_Unserializer::$DEFAULT_RESOLVER = $r;
		}
		$this->resolver = $r;
	}}
	public $buf;
	public $pos;
	public $length;
	public $cache;
	public $scache;
	public $resolver;
	public function readDigits() {
		$k = 0;
		$s = false;
		$fpos = $this->pos;
		while(true) {
			$c = ord(substr($this->buf,$this->pos,1));
			if(($c === 0)) {
				break;
			}
			if($c === 45) {
				if($this->pos !== $fpos) {
					break;
				}
				$s = true;
				$this->pos++;
				continue;
			}
			$tmp = null;
			if($c >= 48) {
				$tmp = $c > 57;
			} else {
				$tmp = true;
			}
			if($tmp) {
				break;
			}
			$k = $k * 10 + ($c - 48);
			$this->pos++;
			unset($tmp,$c);
		}
		if($s) {
			$k = $k * -1;
		}
		return $k;
	}
	public function readFloat() {
		$p1 = $this->pos;
		while(true) {
			$c = ord(substr($this->buf,$this->pos,1));
			if(($c === 0)) {
				break;
			}
			$tmp = null;
			$tmp1 = null;
			$tmp2 = null;
			if($c >= 43) {
				$tmp2 = $c < 58;
			} else {
				$tmp2 = false;
			}
			if(!$tmp2) {
				$tmp1 = $c === 101;
			} else {
				$tmp1 = true;
			}
			if(!$tmp1) {
				$tmp = $c === 69;
			} else {
				$tmp = true;
			}
			if($tmp) {
				$this->pos++;
			} else {
				break;
			}
			unset($tmp2,$tmp1,$tmp,$c);
		}
		return Std::parseFloat(_hx_substr($this->buf, $p1, $this->pos - $p1));
	}
	public function unserializeObject($o) {
		while(true) {
			if($this->pos >= $this->length) {
				throw new HException("Invalid object");
			}
			if(ord(substr($this->buf,$this->pos,1)) === 103) {
				break;
			}
			$k = $this->unserialize();
			if(!Std::is($k, _hx_qtype("String"))) {
				throw new HException("Invalid object key");
			}
			$v = $this->unserialize();
			$o->{$k} = $v;
			unset($v,$k);
		}
		$this->pos++;
	}
	public function unserializeEnum($edecl, $tag) {
		if(ord(substr($this->buf,$this->pos++,1)) !== 58) {
			throw new HException("Invalid enum format");
		}
		$nargs = $this->readDigits();
		if($nargs === 0) {
			return Type::createEnum($edecl, $tag, null);
		}
		$args = new _hx_array(array());
		while(true) {
			$nargs = $nargs - 1;
			if(!($nargs + 1 > 0)) {
				break;
			}
			$args->push($this->unserialize());
		}
		return Type::createEnum($edecl, $tag, $args);
	}
	public function unserialize() {
		{
			$_g = ord(substr($this->buf,$this->pos++,1));
			switch($_g) {
			case 65:{
				$name = $this->unserialize();
				$cl = $this->resolver->resolveClass($name);
				if($cl === null) {
					throw new HException("Class not found " . _hx_string_or_null($name));
				}
				return $cl;
			}break;
			case 66:{
				$name1 = $this->unserialize();
				$e = $this->resolver->resolveEnum($name1);
				if($e === null) {
					throw new HException("Enum not found " . _hx_string_or_null($name1));
				}
				return $e;
			}break;
			case 67:{
				$name2 = $this->unserialize();
				$cl1 = $this->resolver->resolveClass($name2);
				if($cl1 === null) {
					throw new HException("Class not found " . _hx_string_or_null($name2));
				}
				$o = Type::createEmptyInstance($cl1);
				$this->cache->push($o);
				$o->hxUnserialize($this);
				if(ord(substr($this->buf,$this->pos++,1)) !== 103) {
					throw new HException("Invalid custom data");
				}
				return $o;
			}break;
			case 77:{
				$h = new haxe_ds_ObjectMap();
				$this->cache->push($h);
				$buf = $this->buf;
				while(ord(substr($this->buf,$this->pos,1)) !== 104) {
					$s = $this->unserialize();
					$h->set($s, $this->unserialize());
					unset($s);
				}
				$this->pos++;
				return $h;
			}break;
			case 82:{
				$n = $this->readDigits();
				$tmp = null;
				if($n >= 0) {
					$tmp = $n >= $this->scache->length;
				} else {
					$tmp = true;
				}
				if($tmp) {
					throw new HException("Invalid string reference");
				}
				return $this->scache[$n];
			}break;
			case 97:{
				$buf1 = $this->buf;
				$a = new _hx_array(array());
				$this->cache->push($a);
				while(true) {
					$c = ord(substr($this->buf,$this->pos,1));
					if($c === 104) {
						$this->pos++;
						break;
					}
					if($c === 117) {
						$this->pos++;
						$n1 = $this->readDigits();
						$a[$a->length + $n1 - 1] = null;
						unset($n1);
					} else {
						$a->push($this->unserialize());
					}
					unset($c);
				}
				return $a;
			}break;
			case 98:{
				$h1 = new haxe_ds_StringMap();
				$this->cache->push($h1);
				$buf2 = $this->buf;
				while(ord(substr($this->buf,$this->pos,1)) !== 104) {
					$s1 = $this->unserialize();
					$h1->set($s1, $this->unserialize());
					unset($s1);
				}
				$this->pos++;
				return $h1;
			}break;
			case 99:{
				$name3 = $this->unserialize();
				$cl2 = $this->resolver->resolveClass($name3);
				if($cl2 === null) {
					throw new HException("Class not found " . _hx_string_or_null($name3));
				}
				$o1 = Type::createEmptyInstance($cl2);
				$this->cache->push($o1);
				$this->unserializeObject($o1);
				return $o1;
			}break;
			case 100:{
				return $this->readFloat();
			}break;
			case 102:{
				return false;
			}break;
			case 105:{
				return $this->readDigits();
			}break;
			case 106:{
				$name4 = $this->unserialize();
				$edecl = $this->resolver->resolveEnum($name4);
				if($edecl === null) {
					throw new HException("Enum not found " . _hx_string_or_null($name4));
				}
				$this->pos++;
				$index = $this->readDigits();
				$tag = _hx_array_get(Type::getEnumConstructs($edecl), $index);
				if($tag === null) {
					throw new HException("Unknown enum index " . _hx_string_or_null($name4) . "@" . _hx_string_rec($index, ""));
				}
				$e1 = $this->unserializeEnum($edecl, $tag);
				$this->cache->push($e1);
				return $e1;
			}break;
			case 107:{
				return Math::$NaN;
			}break;
			case 108:{
				$l = new HList();
				$this->cache->push($l);
				$buf3 = $this->buf;
				while(ord(substr($this->buf,$this->pos,1)) !== 104) {
					$l->add($this->unserialize());
				}
				$this->pos++;
				return $l;
			}break;
			case 109:{
				return Math::$NEGATIVE_INFINITY;
			}break;
			case 110:{
				return null;
			}break;
			case 111:{
				$o2 = _hx_anonymous(array());
				$this->cache->push($o2);
				$this->unserializeObject($o2);
				return $o2;
			}break;
			case 112:{
				return Math::$POSITIVE_INFINITY;
			}break;
			case 113:{
				$h2 = new haxe_ds_IntMap();
				$this->cache->push($h2);
				$buf4 = $this->buf;
				$c1 = ord(substr($this->buf,$this->pos++,1));
				while($c1 === 58) {
					$i = $this->readDigits();
					$h2->set($i, $this->unserialize());
					$c1 = ord(substr($this->buf,$this->pos++,1));
					unset($i);
				}
				if($c1 !== 104) {
					throw new HException("Invalid IntMap format");
				}
				return $h2;
			}break;
			case 114:{
				$n2 = $this->readDigits();
				$tmp1 = null;
				if($n2 >= 0) {
					$tmp1 = $n2 >= $this->cache->length;
				} else {
					$tmp1 = true;
				}
				if($tmp1) {
					throw new HException("Invalid reference");
				}
				return $this->cache[$n2];
			}break;
			case 115:{
				$len = $this->readDigits();
				$buf5 = $this->buf;
				$tmp2 = null;
				if(ord(substr($this->buf,$this->pos++,1)) === 58) {
					$tmp2 = $this->length - $this->pos < $len;
				} else {
					$tmp2 = true;
				}
				if($tmp2) {
					throw new HException("Invalid bytes length");
				}
				$codes = haxe_Unserializer::$CODES;
				if($codes === null) {
					$codes = haxe_Unserializer::initCodes();
					haxe_Unserializer::$CODES = $codes;
				}
				$i1 = $this->pos;
				$rest = $len & 3;
				$size = null;
				if($rest >= 2) {
					$size = $rest - 1;
				} else {
					$size = 0;
				}
				$size1 = ($len >> 2) * 3 + $size;
				$max = $i1 + ($len - $rest);
				$bytes = haxe_io_Bytes::alloc($size1);
				$bpos = 0;
				while($i1 < $max) {
					$i1 = $i1 + 1;
					$c11 = $codes[ord(substr($buf5,$i1 - 1,1))];
					$i1 = $i1 + 1;
					$c2 = $codes[ord(substr($buf5,$i1 - 1,1))];
					{
						$bpos = $bpos + 1;
						$pos = $bpos - 1;
						{
							$this1 = $bytes->b;
							$this1->s[$pos] = chr($c11 << 2 | $c2 >> 4);
							unset($this1);
						}
						unset($pos);
					}
					$i1 = $i1 + 1;
					$c3 = $codes[ord(substr($buf5,$i1 - 1,1))];
					{
						$bpos = $bpos + 1;
						$pos1 = $bpos - 1;
						{
							$this2 = $bytes->b;
							$this2->s[$pos1] = chr($c2 << 4 | $c3 >> 2);
							unset($this2);
						}
						unset($pos1);
					}
					$i1 = $i1 + 1;
					$c4 = $codes[ord(substr($buf5,$i1 - 1,1))];
					{
						$bpos = $bpos + 1;
						$pos2 = $bpos - 1;
						{
							$this3 = $bytes->b;
							$this3->s[$pos2] = chr($c3 << 6 | $c4);
							unset($this3);
						}
						unset($pos2);
					}
					unset($c4,$c3,$c2,$c11);
				}
				if($rest >= 2) {
					$i1 = $i1 + 1;
					$c12 = $codes[ord(substr($buf5,$i1 - 1,1))];
					$i1 = $i1 + 1;
					$c21 = $codes[ord(substr($buf5,$i1 - 1,1))];
					{
						$bpos = $bpos + 1;
						$pos3 = $bpos - 1;
						{
							$this4 = $bytes->b;
							$this4->s[$pos3] = chr($c12 << 2 | $c21 >> 4);
						}
					}
					if($rest === 3) {
						$i1 = $i1 + 1;
						$c31 = $codes[ord(substr($buf5,$i1 - 1,1))];
						{
							$bpos = $bpos + 1;
							$pos4 = $bpos - 1;
							{
								$this5 = $bytes->b;
								$this5->s[$pos4] = chr($c21 << 4 | $c31 >> 2);
							}
						}
					}
				}
				$tmp3 = $this;
				$tmp3->pos = $tmp3->pos + $len;
				$this->cache->push($bytes);
				return $bytes;
			}break;
			case 116:{
				return true;
			}break;
			case 118:{
				$d = null;
				$tmp4 = null;
				$tmp5 = null;
				$tmp6 = null;
				$tmp7 = null;
				$tmp8 = null;
				$tmp9 = null;
				$tmp10 = null;
				$tmp11 = null;
				if(ord(substr($this->buf,$this->pos,1)) >= 48) {
					$tmp11 = ord(substr($this->buf,$this->pos,1)) <= 57;
				} else {
					$tmp11 = false;
				}
				if($tmp11) {
					$tmp10 = ord(substr($this->buf,$this->pos + 1,1)) >= 48;
				} else {
					$tmp10 = false;
				}
				if($tmp10) {
					$tmp9 = ord(substr($this->buf,$this->pos + 1,1)) <= 57;
				} else {
					$tmp9 = false;
				}
				if($tmp9) {
					$tmp8 = ord(substr($this->buf,$this->pos + 2,1)) >= 48;
				} else {
					$tmp8 = false;
				}
				if($tmp8) {
					$tmp7 = ord(substr($this->buf,$this->pos + 2,1)) <= 57;
				} else {
					$tmp7 = false;
				}
				if($tmp7) {
					$tmp6 = ord(substr($this->buf,$this->pos + 3,1)) >= 48;
				} else {
					$tmp6 = false;
				}
				if($tmp6) {
					$tmp5 = ord(substr($this->buf,$this->pos + 3,1)) <= 57;
				} else {
					$tmp5 = false;
				}
				if($tmp5) {
					$tmp4 = ord(substr($this->buf,$this->pos + 4,1)) === 45;
				} else {
					$tmp4 = false;
				}
				if($tmp4) {
					$d = Date::fromString(_hx_substr($this->buf, $this->pos, 19));
					$tmp12 = $this;
					$tmp12->pos = $tmp12->pos + 19;
				} else {
					$d = Date::fromTime($this->readFloat());
				}
				$this->cache->push($d);
				return $d;
			}break;
			case 119:{
				$name5 = $this->unserialize();
				$edecl1 = $this->resolver->resolveEnum($name5);
				if($edecl1 === null) {
					throw new HException("Enum not found " . _hx_string_or_null($name5));
				}
				$e2 = $this->unserializeEnum($edecl1, $this->unserialize());
				$this->cache->push($e2);
				return $e2;
			}break;
			case 120:{
				throw new HException($this->unserialize());
			}break;
			case 121:{
				$len1 = $this->readDigits();
				$tmp13 = null;
				if(ord(substr($this->buf,$this->pos++,1)) === 58) {
					$tmp13 = $this->length - $this->pos < $len1;
				} else {
					$tmp13 = true;
				}
				if($tmp13) {
					throw new HException("Invalid string length");
				}
				$s2 = _hx_substr($this->buf, $this->pos, $len1);
				$tmp14 = $this;
				$tmp14->pos = $tmp14->pos + $len1;
				$s2 = urldecode($s2);
				$this->scache->push($s2);
				return $s2;
			}break;
			case 122:{
				return 0;
			}break;
			default:{
			}break;
			}
		}
		$this->pos--;
		$tmp15 = "Invalid char " . _hx_string_or_null(_hx_char_at($this->buf, $this->pos)) . " at position ";
		throw new HException(_hx_string_or_null($tmp15) . _hx_string_rec($this->pos, ""));
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $DEFAULT_RESOLVER;
	static $BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
	static $CODES = null;
	static function initCodes() {
		$codes = new _hx_array(array());
		{
			$_g1 = 0;
			$_g = strlen(haxe_Unserializer::$BASE64);
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				$codes[ord(substr(haxe_Unserializer::$BASE64,$i,1))] = $i;
				unset($i);
			}
		}
		return $codes;
	}
	static function run($v) {
		return _hx_deref(new haxe_Unserializer($v))->unserialize();
	}
	function __toString() { return 'haxe.Unserializer'; }
}
haxe_Unserializer::$DEFAULT_RESOLVER = new haxe__Unserializer_DefaultResolver();
